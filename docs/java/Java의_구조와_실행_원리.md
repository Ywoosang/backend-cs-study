# Java의 구조와 실행 원리

## Java 의 특징

### 요약 정리
1. 운영체제에 독립적
2. 객체 지향 언어이기 때문에 재사용성, 유지보수성이 좋음
3. 멀티 스레드를 지원하기 때문에 병렬 처리가 가능
4. 가비지 컬렉션이 자동적으로 메모리 관리
5. 다양한 라이브러리와 API를 지원
6. 대규모 프로젝트에서 안정적으로 동작

### 1. 운영체제에 독립적
Java는 "Write Once, Run Anywhere" 철학에 기반
- Java 소스 코드가 컴파일되면 **바이트코드(.class 파일)**로 변환
- 바이트코드는 특정 운영 체제와 하드웨어에 종속되지 않고, **JVM(Java Virtual Machine)**을 통해 실행
- 운영 체제마다 JVM만 제공되면 동일한 바이트코드를 실행할 수 있기 때문에 플랫폼 독립성을 제공

### 2. 객체 지향 언어이기 때문에 재사용성, 유지보수성이 좋음
Java는 객체 지향 프로그래밍(OOP)의 주요 개념인 캡슐화, 상속, 다형성 등을 지원한다.
- 재사용성: 상속을 통해 기존 클래스를 재사용하거나 확장할 수 있음
- 유지보수성: 캡슐화를 통해 데이터와 메서드를 한데 묶어, 코드의 수정 범위를 최소화할 수 있음
- 구조화: 객체 중심의 설계로 대규모 프로젝트에서도 코드의 가독성과 구조화가 용이

### 3.멀티 스레드를 지원하기 때문에 병렬 처리가 가능
Java는 내장된 멀티스레드 지원을 통해 효율적인 병렬 처리를 제공한다.
- 스레드(Thread): 한 프로그램 내에서 여러 작업을 동시에 실행할 수 있도록 지원
Java는 java.lang.Thread 클래스와 Runnable 인터페이스를 제공해 멀티스레드 구현이 가능하다.
이를 통해 다중 CPU 코어를 효과적으로 활용할 수 있어 고성능 애플리케이션 개발이 가능하다.

### 4.가비지 컬렉션이 자동적으로 메모리 관리
Java는 프로그래머가 직접 메모리를 해제하지 않아도 되는 가비지 컬렉션(Garbage Collection) 기능을 제공한다.
- JVM의 Garbage Collector(GC)가 더 이상 사용되지 않는 객체를 자동으로 탐지하고 메모리를 회수

메모리 누수(Leak)나 해제되지 않은 메모리로 인한 문제를 줄여 안정성을 높일 수 있고,  개발자는 메모리 관리에 신경 쓰기보다 비즈니스 로직 구현에 집중할 수 있다.

### 5. 다양한 라이브러리와 API를 지원
- Java Standard Library: 파일 입출력, 네트워크, 데이터베이스 연결, 암호화 등 기본 기능
- 오픈소스 라이브러리: Spring, Hibernate, Apache Commons, Jackson 등 생산성을 높여주는 강력한 라이브러리 생태계 존재
  
개발자는 복잡한 기능을 직접 구현하지 않아도 라이브러리를 활용하여 효율적으로 애플리케이션을 개발할 수 있다.
### 6. 대규모 프로젝트에서 안정적으로 동작
- 스케일링: Java는 멀티스레드, 네트워크 처리, 클러스터링 등을 통해 대규모 애플리케이션에서 안정적으로 동작
- 안전성: 강력한 예외 처리와 메모리 관리 기능이 있어 오류 발생을 줄이고 안정성을 보장
- 커뮤니티 지원: 오랜 역사와 넓은 사용자 기반 덕분에 다양한 도구와 프레임워크(Spring, Apache 등)이 대규모 프로젝트 개발에 활용
- 배포 가능성: Java는 다양한 환경(웹, 데스크톱, 모바일, 클라우드)에서 안정적으로 배포되고 실행될 수 있음


## Java 의 단점

1. 속도 문제
- JIT 컴파일과 JVM의 오버헤드로 인해 네이티브 언어(C/C++)보다 실행 속도가 느릴 수 있음
2. 메모리 소비
- 가비지 컬렉션(GC)으로 메모리 관리는 편리하지만, 메모리 사용량이 많아질 수 있음
- 객체 지향 언어이기 때문에 객체를 생성하고 관리하는 과정에서 불필요한 객체 생성이 발생하는 경우
3. 복잡한 구문
- Java의 문법은 다른 현대적 언어(Python, Kotlin)에 비해 상대적으로 장황하고 복잡
4. 배포 파일 크기
- JVM 설치가 필요하고, JAR 파일 크기가 큰 경우 배포가 번거로울 수 있음

## Java 실행 과정

1. 소스 코드 작성
   개발자는 Java로 작성한 소스 코드 파일을 생성한다.
2. 컴파일
   소스 코드는 **Javac(Java Compiler)**에 의해 OS 에 종속되지 않은 바이트코드(.class 파일)로 컴파일된다.
3. 실행
   JVM이 바이트코드를 읽어 실행하는데, 두 가지 방식으로 바이트코드를 처리한다.
    - **인터프리터(Interpreter)** 
    - **JIT(Just-In-Time) 컴파일러**
   
## Java Bytecode

**Java Bytecode**는 Java 소스 코드를 컴파일한 후 생성되는 중간 코드(intermediate code)로`.class` 파일에 저장되며, JVM(Java Virtual Machine)이 실행할 수 있는 명령어들의 집합이다.
바이트코드는 기계어와 유사한 구조를 가지고 있지만, CPU나 운영 체제가 아닌 **JVM만이 이해할 수 있는 코드**다.  
- 바이트코드로 인해 Java는 플랫폼 독립성을 제공 

## Java의 인터프리터(interpreter) 방식과 JIT 컴파일(compile) 방식

### 인터프리터 방식
JVM이 바이트코드(.class 파일)를 한 줄씩 읽고 실행하는 방식이다.
- 장점: 초기 실행 속도가 빠르고 디버깅이 용이합니다.
- 단점: 코드가 반복적으로 실행되면 성능이 떨어집니다(바이트코드를 계속 해석하기 때문).
초기 JVM에서 주로 사용되었으나, 현대 JVM에서는 JIT의 보조 역할로 사용된다.

### JIT 컴파일 방식 
JVM이 바이트코드를 실행 중에 자주 사용되는 코드(핫스팟)를 네이티브 코드(기계어)로 변환하는 방식이다.
- 장점: 반복되는 코드에서 높은 성능을 발휘하며, 최적화된 네이티브 코드로 실행 속도를 단축합니다.
- 단점: 컴파일 과정에서 약간의 지연이 발생하며 메모리 사용량이 증가합니다.
현대 JVM에서 성능 최적화를 위해 기본적으로 사용된다.

## 버전 별 특징

### LTS 버전(8,11,17)
- Java 8: 함수형 프로그래밍(Lambda, Stream API) 도입, 인터페이스에 구현메서드 추가 기능
- Java 11: 생산성 향상(var 키워드), HTTP/2와 비동기 통신 지원, String 처리 개선 (lines(), strip() 메서드 추가)
- Java 17: Sealed Class 로 클래스 상속 제한, 성능 및 안정성 개선

### Java17 사용 이유

- LTS 버전
    - LTS 버전은 긴 지원 주기를 가지므로, 버전 업그레이드 주기를 **느리게 조정**할 수 있다. 기업 환경에서는 모든 시스템을 빠르게 업그레이드하기 어려우므로, LTS 버전을 사용하면 현실적인 업그레이드 전략이 가능하다.
        - 예: Java 8에서 바로 Java 11로 업그레이드하거나, Java 11에서 Java 17로 건너뛰는 방식이 가능
    - LTS 버전은 출시 이후 **장기간 보안 패치와 버그 수정**을 제공해 안정성이 보장되므로 대규모 애플리케이션에서도 안심하고 사용할 수 있다.
    - 많은 오픈소스 도구 및 프레임워크(Spring, Hibernate 등)은 **LTS 버전을 우선적으로 지원한다.**
- Java 15에서 정식 기능이 된 텍스트 블록으로 여러 줄 문자열을 작성하기 용이
    ```java
    // 기존
    String html = "<html>\n" +
              "  <body>\n" +
              "    <h1>Hello, World!</h1>\n" +
              "  </body>\n" +
              "</html>";
              
    // 텍스트 블록
    String html = """
        <html>
            <body>
                <h1>Hello, World!</h1>
            </body>
        </html>
    """;
    ```

- Java 16에서 도입된 Record를 사용할 수 있어  불변 객체를 간단히 정의할 수 있음
- Java 17에서 G1 GC와 ZGC가 크게 개선되어 더 낮은 지연 시간과 높은 성능을 제공

 

## JDK 와 JRE

JDK는 JRE를 포함하므로, JDK가 있으면 JRE도 사용할 수 있다. JRE는 실행 환경만 제공하며, JDK는 개발과 실행 환경 모두를 제공한다.
Java 개발자는 일반적으로 JDK를 사용하며, Java 애플리케이션 사용자는 JRE를 설치해 실행한다.
 
- JRE: Java 프로그램을 실행하기 위한 도구. 컴파일된 Java를 실행할 수 있지만 개발은 불가능
- JDK: Java 프로그램을 개발하고 실행할 수 있는 도구. JRE를 포함

JRE(Java Runtime Environment)
- 사용자가 이미 개발된 Java 애플리케이션을 실행하려고 할 때 JRE가 필요
  - ex) Java 기반의 데스크톱 애플리케이션을 실행

JDK(Java Development Kit)
- JRE + 컴파일러(javac), jdb, javadoc 등 
- 개발자가 Java 애플리케이션을 작성, 컴파일, 디버깅하려면 JDK가 필요
- JDK에는 JRE가 포함되어 있으므로, 개발 도구와 실행 환경을 모두 제공